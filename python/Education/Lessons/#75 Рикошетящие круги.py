# Перед тем, как начать делать это задание, перейдите на урок «Бесконечный цикл» из раздела «Цикл while и модули». Прочитайте условия и вспомните, как вы сделали «летающий» туда-сюда прямоугольник.

# В этом уроке надо написать программу, которая будет рисовать рикошетящие круги. Выглядеть это должно примерно так:
# https://letpy.com/static/lessons/lesson.800.1101.gif

# Размеры холста в этом уроке должны быть 400 на 400 пикселей. Для изменения размеров холста нужно передать именованные аргументы width и height в вызов Canvas.

# Первым делом присвойте переменной circles пустой список. Затем сделайте цикл for или while на 5 итераций, так как кругов должно быть именно 5.

# В каждой итерации в список circles должен добавляться словарь с тремя ключами: "dx" и "dy" для шагов передвижения по горизонтали и вертикали, а также "id" для хранения идентификатора.

# В ключ "id" должен быть записан идентификатор, который вернет метод create_oval. Размеры кругов могут быть любыми, главное, чтобы это были круги. То есть их размеры по вертикали и горизонтали должны быть одинаковыми. Начальные координаты кругов должны быть случайными. Для генерации случайных координат используйте функцию randint из модуля random. Важно, чтобы круги не выходили за пределы холста.

# Каждый круг должен быть закрашен случайным цветом. Для того чтобы закрасить круг, в метод create_oval нужно передать именованный аргумент fill
# canvas.create_oval(100, 100, 200, 200, fill='red')

# Все доступные в tkinter цвета можно посмотреть здесь. Для того чтобы каждый круг закрашивался в случайный цвет, можно создать список colors, добавить туда несколько понравившихся цветов, а затем выбирать из этого списка случайный элемент при помощи функции choice модуля random.

# Значения ключей "dx" и "dy" должны быть случайными целыми числами в промежутке от -10 до 10. Для их генерации используйте все ту же функцию randint из модуля random.

# Полное описание модуля random и его функций есть в нашем справочнике.

# После добавления в список пяти словарей нужно сделать бесконечный цикл. Внутри бесконечного цикла должен быть цикл for, который «пробегает» по списку кругов circles.

# В каждой итерации этого цикла первым делом нужно проверить, не вышли ли координаты круга за границы холста. Для получения текущих координат круга используйте уже знакомый метод coords. Если передать в этот метод только один аргумент (идентификатор фигуры), он вернет список с координатами

# for circle in circles:
#     x0, y0, x1, y1 = canvas.coords(circle['id'])
    
# Если x0 или у0 меньше нуля нужно менять знак соответствующего шага движения на противоположный. То же самое необходимо делать, если x1 или у1 стали больше 400.

# После всех проверок нужно передвинуть круг с помощью метода холста move. Его первый аргумент — идентификатор фигуры. Второй и третий аргументы — количество пикселей на которое нужно передвинуть фигуру по горизонтали и вертикали соответственно.

# example = canvas.create_oval(100, 100, 200, 200, fill='red')
# # передвинет круг на 10 пикселей влево 
# # и на 10 пикселей вниз
# canvas.move(example, -10, 10)

# После цикла for нужно обновить содержимое окна с помощью update().

# Если круги «летают» слишком быстро, после каждой прорисовки кадра можно делать небольшую паузу в одну сотую секунды, используя time.sleep(0.01)

# # 1
# import tkinter
# import time
# import random

# window = tkinter.Tk()
# canvas = tkinter.Canvas(window, width = 400, height = 400)
# canvas.pack()

# colors = ['red', 'blue', 'green', 'orange', 'purple','yellow', 'pink', 'brown']
# circle = []
# r = 10

# for i in range(5):
#     cx = random.randint(100,300)
#     cy = random.randint(100,300)
#     coordinat = {
#         'idi': canvas.create_oval(cx-r, cy-r, cx+r, cy+r, fill=random.choice(colors)),
#         'dx': random.randint(-10,10),
#         'dy' : random.randint(-10,10)
#     }
#     circle.append(coordinat)
#     r += random.randint(5, 6)

# # for j in circle:
# #     print(canvas.coords(j[0]))
# while True:
#     for j in circle:
#         x0, y0, x1, y1 = canvas.coords(j['idi'])
#         if x0 < 0 or x1 > 400:
#             j['dx'] = -j['dx']
#         if y0 < 0 or y1 > 400:
#             j['dy'] = -j['dy']
#         canvas.move(j['idi'], j['dx'] , j['dy'])

#     canvas.update()
#     time.sleep(0.01)

# window.mainloop()