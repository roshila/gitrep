# Написав программу из прошлого урока, вы, скорее всего, почувствовали, что что‑то не так. Код метода init был одинаковым для всех классов.

# def __init__(self, name):
#     self.name = name

# То есть от дублирования кода мы не избавились. И это не очень хорошо. Писать все в одном классе, а потом расставлять условия в методе ask_for_food — не вариант, ведь мы как раз от этого и хотели избавиться.

# К счастью, при использовании классов и объектно-ориентированного подхода у нас появляется мощный инструмент: наследование.

# Наследование — это создание нового класса на основе уже существующего. При этом вновь созданный класс будет использовать код, написанный в существующем классе.

# Собственно, не будем тянуть кота за хвост и попробуем что‑нибудь отнаследовать. Создадим класс Pet в котором будет одинаковый для всех питомцев метод инициализации

# class Pet:
#     def __init__(self, name):
#         self.name = name

# Классы Cat, Dog и Raccoon отнаследуем от этого класса. Синтаксис наследования прост: достаточно в скобках после название класса написать название класса, от которого мы наследуемся.

# class Cat(Pet):
#     def ask_for_food(self):
#         print('Кот {} требует пищу'.format(self.name))


# class Dog(Pet):
#     def ask_for_food(self):
#         print('Пёс {} хочет есть'.format(self.name))


# class Racoon(Pet):
#     def ask_for_food(self):
#         print('Енот {} уже начинает воровать'.format(self.name))
        
# В терминах объектно-ориентированного программирования класс Pet будет супер-классом для классов Cat, Dog и Raccoon. Также его вполне можно назвать базовым или родительским. Классы Cat, Dog и Raccoon будут подклассами или потомками.

# Эти термины стоит запомнить, потому что дальше мы будем пользоваться именно ими.