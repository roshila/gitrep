# Значения по‑умолчанию вычисляются только один раз — в момент объявления функции. Это важная особенность, незнание которой может привести к сюрпризам. Попробуйте запустить следующий пример:

# default_value = 1

# def f(value=default_value):
#     print(value)

# f(4)    # выведет 4
# f()     # выведет 1 – значение по-умолчанию
# default_value = 10
# f()     # все равно 1, так как default_value 
#         # было равно 1 на момент объявления
        
# Допустим, мы хотим сделать функцию, которая принимает в качестве аргументов какое‑то значение и список, добавляет это значение в список и выводит список на экран. Причем, если список не передан, по умолчанию он должен быть равен пустому списку:

# def add_value(value, values=[]):
#     values.append(value)
#     print(values)

# Если попробовать вызвать такую функцию несколько раз без второго аргумента, получится не совсем то, чего нам хотелось бы:

# add_value(1)
# add_value(2)

# При втором вызове функции add_value мы не передаем список в качестве аргумента и хотим, чтобы он был пустым, однако в нем уже есть значение из первого вызова функции:

# [1]
# [1, 2]

# Проблема тут в том, что переменная values будет ассоциирована с пустым списком один раз, и между вызовами будет сохранять свое значение.

# Правильно будет объявить нашу функцию таким образом:

# def add_value(value, values=None):
#     if values is None:
#         values = []
#     values.append(value)
#     print(values)


# Особенности значений по умолчанию #156
# Значения по‑умолчанию вычисляются только один раз — в момент объявления функции. Это важная особенность, незнание которой может привести к сюрпризам. Попробуйте запустить следующий пример:

# default_value = 1

# def f(value=default_value):
#     print(value)

# f(4)    # выведет 4
# f()     # выведет 1 – значение по-умолчанию
# default_value = 10
# f()     # все равно 1, так как default_value 
#         # было равно 1 на момент объявления
# Допустим, мы хотим сделать функцию, которая принимает в качестве аргументов какое‑то значение и список, добавляет это значение в список и выводит список на экран. Причем, если список не передан, по умолчанию он должен быть равен пустому списку:

# def add_value(value, values=[]):
#     values.append(value)
#     print(values)
# Если попробовать вызвать такую функцию несколько раз без второго аргумента, получится не совсем то, чего нам хотелось бы:

# add_value(1)
# add_value(2)
# При втором вызове функции add_value мы не передаем список в качестве аргумента и хотим, чтобы он был пустым, однако в нем уже есть значение из первого вызова функции:

# [1]
# [1, 2]
# Проблема тут в том, что переменная values будет ассоциирована с пустым списком один раз, и между вызовами будет сохранять свое значение.

# Правильно будет объявить нашу функцию таким образом:

# def add_value(value, values=None):
#     if values is None:
#         values = []
#     values.append(value)
#     print(values)
# Проверьте, теперь программа работает так, как задумано.