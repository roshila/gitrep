# И получившийся в результате работы функции enumerate итератор, и последовательность чисел, полученная с помощью range могут быть преобразованы в список
# a = range(5)
# b = enumerate(a)

# print(a, b)

# print(list(a))
# print(list(b))
# Обязательно запустите эту программу и посмотрите на результат ее работы.
# range(0, 5) <enumerate object>
# [0, 1, 2, 3, 4]
# [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
# Как видите, все сработало как надо и мы получили преобразованные списки.

# Нужно, однако, понимать цену такого преобразования. Итератор, получившийся в результате работы функции enumerate, как и последовательность чисел, полученная с помощью range «ленивы». Это означает, что они создают нужные значения в памяти только тогда, когда это требуется. В случае же преобразования в список, все значения будут записаны в память.

# Разумеется, разница в потребляемой памяти для таких примеров не велика. Но представьте, что range вызван с аргументом в несколько миллионов, а в enumerate передан список из нескольких сотен тысяч слов. В первом примере ниже, порядковый номер слова высчитывается только в нужный момент — только тогда, когда начинается новая итерация. То есть, на протяжении всего цикла это будет одно число в памяти, хоть и постоянно увеличивающееся
# # в каждой итерации enumerate будет 
# # высчитывать порядковый номер слова
# for i, e in enumerate(huge_list_of_words):
#     print(i, e)

# Во втором примере все будет по‑другому
# # в получившемся списке для каждого из 
# # слов будет сохранен порядковый номер
# for i, e in list(enumerate(huge_list_of_words)):
#     print(i, e)

# Для каждого слова будет сохранен порядковый номер, то есть на голом месте мы получили несколько сотен тысяч чисел, которые занимают лишнюю память.

# В общем, стоит помнить о том, что enumerate и range возвращают «ленивые» объекты. И преобразовывать эти последовательности в списки стоит с особенной аккуратностью и только тогда, когда это действительно необходимо.